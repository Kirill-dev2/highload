### 1) Проблемы высоких нагрузок
Домашнее задание Заготовка для социальной сети

#### Цель:
В результате выполнения ДЗ вы создадите базовый скелет социальной сети, который будет развиваться в дальнейших ДЗ.
В данном задании тренируются навыки:
* декомпозиции предметной области;
* построения элементарной архитектуры проекта

#### Инструкция:
Требуется разработать создание и просмотр анкет в социальной сети.

#### Функциональные требования:
* Простейшая авторизация пользователя.
* Возможность создания пользователя, где указывается следующая информация:
* Имя
* Фамилия
* Дата рождения
* Пол
* Интересы
* Город
* Страницы с анкетой.

#### Нефункциональные требования:
* Любой язык программирования
* В качестве базы данных использовать PostgreSQL (при желании и необходимости любую другую SQL БД)
* Не использовать ORM
* Программа должна представлять из себя монолитное приложение.

Не рекомендуется использовать следующие технологии:
* Репликация
* Шардирование
* Индексы
* Кэширование

Для удобства разработки и проверки задания можно воспользоваться этой спецификацией и реализовать в ней методы:
/login
/user/register
/user/get/{id}

Фронт опционален.

Сделать инструкцию по локальному запуску приложения, приложить Postman-коллекцию.

#### Критерии оценки:
Оценка происходит по принципу зачет/незачет.
Требования:
Есть возможность авторизации, регистрации, получение анкет по ID.
Отсутствуют SQL-инъекции.
Пароль хранится безопасно.

### 2) Индексы: оптимизация запросов
Домашнее задание Производительность индексов

####  Цель:
В результате выполнения ДЗ вы воспользуетесь/создадите набор тестовых данных для проведения нагрузочного тестирования, подберете наиболее подходящие индексы и проведете тесты производительности.
В данном задании тренируются навыки:
* (опционально) генерация тестовых данных;
* работа с индексами;
* нагрузочное тестирование;

####  Инструкция:
1. Сгенерировать любым способ 1,000,000 анкет. Имена и Фамилии должны быть реальными, чтобы учитывать селективность индекса. Так же можно воспользовать уже готовым списком как основой.
2. Реализовать функционал поиска анкет по префиксу имени и фамилии (одновременно) в вашей социальной сети (реализовать метод /user/search из спецификации) (запрос в форме firstName LIKE ? and secondName LIKE ?). Сортировать вывод по id анкеты.
3. Провести нагрузочные тесты этого метода. Поиграть с количеством одновременных запросов. 1/10/100/1000.
4. Построить графики и сохранить их в отчет
5. Сделать подходящий индекс.
6. Повторить пункт 3 и 4.
7. В качестве результата предоставить отчет в котором должны быть:
8. графики latency до индекса;
9. графики throughput до индекса;
10. графики latency после индекса;
11. графики throughput после индекса;
12. запрос добавления индекса;
13. explain запросов после индекса;
14. объяснение почему индекс именно такой;

##### Критерии оценки:
* Правильно выбраны индексы.
* Нагрузочное тестирование проведено и результаты адекватны.
* В случае генерации тестовых данных самостоятельно, убедиться что эти данные "похожи" на настоящие.

### 3) Репликация
#### Цель:
В результате выполнения ДЗ вы настроите разные виды репликации, протестируете их влияние на производительность системы и убедитесь, что в случае сихнронной репликации вы не теряете данные при аварии.
В данном задании тренируются навыки:
* обеспечение отказоустойчивости проекта;
* администрирование PostgreSQL;
* настройка репликации;
* проведение нагрузочных тестов.

#### Описание/Пошаговая инструкция выполнения домашнего задания:
1. Настраиваем асинхронную репликацию.
2. Выбираем 2 запроса на чтение (/user/get/{id} и /user/search из спецификации) и переносим их на чтение со слейва.
3. Делаем нагрузочный тест по методам (/user/get/{id} и /user/search из спецификации), которые перевели на слейв до и после репликации. Замеряем нагрузку мастера (CPU, la, disc usage, memory usage).
4. Настроить 2 слейва и 1 мастер.
5. Включить потоковую репликацию.
6. (Опционально) воспользоваться одним из кластерных расширения Postgres (например patroni).
7. Настроить кворумную синхронную репликацию.
8. Создать нагрузку на запись в любую тестовую таблицу. На стороне, которой нагружаем считать, сколько строк мы успешно записали.
9. Убиваум одну из реплик (kill -9, docker stop)
10. Заканчиваем нагрузку на запись.
11. Выбираем самый свежий слейв. Промоутим его до мастера. Переключаем на него второй слейв.
12. Проверяем, есть ли потери транзакций.

#### Критерии оценки:
1. В отчете корректно описано, как настроена репликация.
2. 2 запроса переведено на чтение со слейва.
3. Нагрузочное тестирование показало, что нагрузка перешла на слейв.
4. Проведен эксперимент по потере и непотере транзакций при аварийной остановке master.

### 4) Кеширование
#### Цель:
В результате выполнения ДЗ вы создадите ленту постов друзей социальной сети
В данном задании тренируются навыки:
* работа с кешами;
* работа с очередями;
* проектирование масштабируемых архитектур.

#### Инструкция:
Реализовать функционал:
* (опционально) Добавление/удаление друга (методы /friend/add, /friend/delete из спецификации)
* (опционально) CRUD для постов пользователей (методы /post/create, /post/update, /post/delete, /post/get из спецификации)
* Лента постов друзей (метод /post/feed из спецификации

#### Дополнительные материалы
[ссылка](https://github.com/OtusTeam/highload/blob/master/homework/posts.txt) на сгенерированные тексты постов (опциально, можно сгенерировать самостоятельно)

#### Требования к ленте постов друзей
* Лента постов друзей формируется на уровне кешей
* (Опционально) Формирование ленты производить через постановку задачи в очередь на часть друзей, чтобы избежать "эффекта Леди Гаги"/celebrity (один пользователь пишет сильно больше среднего)
* В ленте держать последние 1000 обновлений друзей
* Лента должна кешироваться

#### Критерии оценки:
1. Верно работает инвалидация кеша.
2. (опционально) Обновление лент работает через очередь.
3. Есть возможность перестройки кешей из СУБД.

### 5) Очереди и отложенное выполнение
#### Цель:
Разработать WebSocket сервер, при помощи которого подключенные клиенты будут сразу получать обновления постов своих друзей.
Такой подход позволит сэкономить ресурсы и обновлять молниеносно ленты активных клиентов.

#### Реализовать функционал:
* Создание поста (метод /post/create из спецификации)
* Отправка сообщений в канал /post/feed/posted через websocket согласно спецификации

#### Требования:
* при добавлении нового поста друга подписчику websocket'а должно приходить событие о новом посте, тем самым обеспечивая обновление ленты в реальном времени
* при реализации обязательно обеспечить отправку только целевым пользователям это событие (можно применить Routing Key из RabbitMQ)

#### Критерии оценки:
1. При добавлении поста у друга, лента должна обновляться автоматически (с небольшой задержкой).
2. Корректная работа сервиса вебсокетов.
3. Линейная масштабируемость сервиса вебсокетов.
4. Описан процесс масштабирования RabbitMQ.

### 6) In-Memory СУБД
#### Цель:
В результате выполнения ДЗ вы перенесете хранение одного из модулей вашего приложения в tarantool.
В данном задании тренируются навыки:
* администрирование tarantool;
* разработка хранимых процедур для tarantool.

#### Инструкция:
1. Выбрать один из модулей приложения: например диалоги;
2. Провести нагрузочное тестирование этого модуля для дальнейшего сравнения
3. Вынести хранение данных из SQL БД в Tarantool
4. Провести нагрузочное тестирование снова
5. Сравнить результаты нагрузочного тестирования

#### Требования:
Для общения с tarantool'ом использовать процедуры (функции lua), не использовать прямые запросы в space'ы при помощи драйвера

#### Критерии оценки:
1. Один из модулей вынесен в tarantool
2. Общение с tarantool'ом происходит при помощи хранимых процедур (lua-функции)
3. Проведено нагрузочное тестирование и есть сравнение ДО и ПОСЛЕ

### 7) Шардирование
#### Цель:
В результате выполнения ДЗ вы создадите базовый скелет микросервиса, который будет развиваться в дальнейших ДЗ.
В данном задании тренируются навыки:
* декомпозиции предметной области;
* построения элементарной архитектуры проекта.

#### Инструкция:
* Отправка сообщения пользователю (метод /dialog/{user_id}/send из спецификации)
* Получение диалога между двумя пользователями (метод /dialog/{user_id}/list из спецификации)

#### Требования:
* Обеспечить горизонтальное масштабирование хранилищ на запись с помощью шардинга.
* Предусмотреть:
* Возможность решардинга
* (опционально) “Эффект Леди Гаги” (один пользователь пишет сильно больше среднего)
* Наиболее эффективную схему.

#### Критерии оценки:
1. (опционально) Верно выбран ключ шардирования с учетом "эффекта Леди Гаги"
2. В отчете описан процесс решардинга без даунтайма

### 8) Принципы организации микросервисов. Типы взаимодействий
#### Цель:
В результате выполнения ДЗ вы перенесете бизнес-домен монолитного приложения в отдельный сервис.
В данном задании тренируются навыки:
* декомпозиции предметной области;
* разделение монолитного приложения;
* работа с HTTP;
* работа с REST API или gRPC.

#### Инструкция:
* Вынести систему диалогов в отдельный сервис.

#### Требования:
* Взаимодействия монолитного сервиса и сервиса чатов реализовать на REST API или gRPC.
* Организовать сквозное логирование запросов (x-request-id).
* Предусмотреть то, что не все клиенты обновляют приложение быстро и кто-то может ходить через старое API (сохранение обратной совместимости).

#### Критерии оценки:
1. Описан протокол взаимодействия.
2. Поддержаны старые клиенты.
3. Новые клиенты верно ходят через новый API.

### 9) Балансировка и отказоустойчивость
#### Цель:
В результате выполнения ДЗ вы уменьшите число точек отказа в вашем приложении.
В данном задании тренируются навыки:
* проектирование отказоустойчивых архитектур;
* настройка nginx;
* настройка HAProxy.

#### Инструкция:
* Поднять несколько слейвов PostgreSQL.
* Реализовать соединение со слейвами PostgreSQL через haproxy.
* Поднять несколько приложений и обеспечить их балансировку через nginx.
* Воспроизвести нагрузку.
* Под нагрузкой с помощью "kill -9" отключить один из слейвов PostgreSQL. Убедится, что система осталась работоспособной.
* Под нагрузкой с помощью "kill -9" отключить один из инстансов бэкенда. Убедится, что система осталась работоспособной.

#### Критерии оценки:
1. В отчете верно описана конфигурация haproxy. (MySQL)
2. В отчете верно описана конфигурация nginx. (MySQL)
3. В отчете верно описаны условия эксперимента.
4. В отчете должны быть логи работы системы.

### 10) Распределенные транзакции
#### Цель:
В результате выполнения ДЗ вы создадите сервис счетчиков. Сервис будет хранить такие счетчики, как число непрочитанных сообщений.
В данном задании тренируются навыки:
* разработка отказоустойчивых сервисов;
* использование кешей.

#### Инструкция:
##### Вариант 1
1. Разработайте сервис счетчиков.
2. Учтите то, что на этот сервис будет большая нагрузка, особенно на чтение.
3. Продумайте, как обеспечить консистентность между счетчиком и реальным числом непрочитанных сообщений. Например, используйте паттерн SAGA.
4. Внедрите сервис для отображения счетчиков.
##### Вариант 2
1. Разработайте и внедрите функционал, в котором будет необходимость применения паттерна SAGA, этот функционал должны быть потенциально нагруженным.

#### Требования:
обеспечение консистентности (SAGA в приоритете)

#### Критерии оценки:
1. Верно описан выбранный паттерн обеспечения консистентности.
2. Выбранная архитектура сервиса подходит для решения задачи.

### 11) Мониторинг и алертинг
#### Цель:
В результате выполнения ДЗ вы организуете мониторинг своего сервиса чатов.
В данном задании тренируются навыки:
* эксплутация prometheus;
* эксплутация grafana;
* эксплутация zabbix.

#### Инструкция:
* развернуть zabbix;
* развернуть prometheus;
* развернуть grafana;
* начать писать в prometheus бизнес-метрики сервиса чатов по принципу RED;
* начать писать в zabbix технические метрики сервера с сервисом чатов;
* организовать дашборд в grafana;

#### Критерии оценки:
1. Сбор технических метрик осуществляется верно.
2. Сбор бизнес метрик осуществляется верно по принципу RED.
3. В grafana организован дашборд.